import { User } from "./User";
import * as published from "./Domain";
import * as ui from "./UIs";
import { InboxOptions, ChatboxOptions, PopupOptions } from "./UIOptions";
/**
 * This object can notify you when the amount of unread conversations changes.
 * You can't instantiate it - instead, get an instance via [[Session.unreads]].
 */
export interface Unreads {
    /**
     * A "change" event is fired on startup right after TalkJS loads, as well as every time the
     * amount of unread conversations changed. The `handler` is invoked with an array of objects with
     * limited information about each conversation, see [[UnreadMessage]].
     */
    on(eventType: "change", handler: (messages: published.UnreadMessage[]) => void): void;
    /**
     * Call this with the same `eventType` and `handler` to stop receiving events.
     */
    off(eventType: "change", handler: (messages: published.UnreadMessage[]) => void): void;
}
/**
 * A session represents a user's active browser tab. It also authenticates your app
 * with TalkJS.
 */
export declare class Session {
    private readonly _eventEmitter;
    private _uiBoxes;
    /**
     * Holds information about unread conversations. Lets your app be notified
     * when the active user receives a new message.
     */
    readonly unreads: Unreads;
    readonly me: User;
    readonly appId: string;
    private readonly _sessionId;
    themePath: string;
    /**
     * Creates a session. Do this once on every page.
     *
     * @param appId Your app's unique TalkJS id. Get it from the dashboard.
     * @param me A `User` object that identifies the currently active user.
     *           The user is uniquely identified by their id; all other fields
     *           (name, photo, etc) are overwritten in the TalkJS database each
     *           time they change.
     *           Alternatively, only pass a user ID (as a string) if you are certain
     *           that the user object exists.
     */
    constructor({ appId, me, signature }: {
        appId: string;
        me: User;
        signature?: string;
    });
    constructor({ appId, me, signature, serverHostname }: {
        appId: string;
        me: User;
        signature?: string;
        serverHostname?: string;
    });
    /**
     * Verifies whether the `appId` is a valid TalkJS credential.
     * Returns a Promise of a boolean, never rejects.
     */
    hasValidCredentials(): Promise<boolean>;
    private _maybeRestorePopup;
    private _trackWindowFocus;
    /**
     * **Deprecated**. This method will keep being supported, but for new projects,
     * we recommend that you use [[Session.getOrCreateConversation]].
     *
     * Returns a `Conversation` object that encapsulates a conversation
     * between `me` (given in the constructor) and `other`.
     *
     * @param other A `User` object that identifies the person to converse with.
     * The user is uniquely identified by their id; all other fields (name, photo
     * etc) are overwritten in the TalkJS database each  time they change.
     *
     * @param topicId An optional identifier for whatever topic, product or order
     * this conversation is about. If you don't specify a topicId, there will be only one
     * conversation for each pair of users. If you do specify one, there will be
     * one conversation for each (me, other, topic) combination.
     *
     * @param subject Only used if `topicId` is given: a human-readable subject
     * of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://yoursite.com/booking/18644|home by the sea>!`.
     * URLs and email addresses are made clickable, and emojis made to work
     * cross-platform.
     *
     * @param custom Additional parameter to store the custom fields, that you
     * want to use in the email template. E.g. `custom.specialToken`
     *
     * @param welcomeMessages System messages that will be send at the start of a conversation.
     *
     * @param photoUrl Photo to be used for this conversation in the TalkJS UI.     *
     */
    getOrStartConversation(other: User, { topicId, subject, custom, welcomeMessages, photoUrl }: {
        topicId?: string;
        subject?: string;
        custom?: {
            [name: string]: string;
        };
        welcomeMessages?: Array<string>;
        photoUrl?: string;
    }): published.Conversation;
    /**
     * **Deprecated**. This method will keep being supported, but for new projects,
     * we recommend that you use [[Session.getOrCreateConversation]].
     *
     * Returns a `Conversation` object that encapsulates a conversation
     * between `me` (given in the constructor) and zero or more other `participants`.
     *
     * @param conversationId A unique identifier for this conversation. Any user with access to this ID can join this
     *                       conversation.
     * @param subject A human-readable subject
     *                of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     *                `Beautiful <https://yoursite.com/booking/18644|home by the sea>!`.
     *                URLs and email addresses are made clickable, and emojis made to work
     *                cross-platform.
     * @param participants An optional list of other people to immediately join into this conversation. If the conversation
     *                     already exists, then the current user plus all users in this list are *added* to the conversation.
     *                     You cannot remove users from the conversation with this function. (but you can with the REST API).
     * @param custom Additional parameter to store the custom fields, that you want to use in the email template. E.g. `custom.specialToken`
     * @param welcomeMessages System messages that will be send at the start of a conversation.
     * @param photoUrl Photo to be used for this conversation in the TalkJS UI.
     */
    getOrStartConversation(conversationId: string, { participants, subject, custom, welcomeMessages, photoUrl }: {
        participants: Array<User>;
        subject?: string;
        custom?: {
            [name: string]: string;
        };
        welcomeMessages?: Array<string>;
        photoUrl?: string;
    }): published.Conversation;
    private _maybeAddMyParticipant;
    /**
     * Returns a `ConversationBuilder` object that encapsulates a conversation
     * between `me` (given in the constructor) and zero or more other `participants`.
     * Use [[ConversationBuilder.setParticipant]] and [[ConversationBuilder.setAttributes]]
     * on the returned object to further set up your conversation.
     *
     * @param conversationId A unique identifier for this conversation, such as a channel name or topic ID.
     * Any user with access to this ID can join this conversation.
     * [Read about how to choose a good conversation ID for your use case](https://talkjs.com/docs/Reference/Concepts/Conversations.html).
     * If you want to make a simple one-on-one conversation, consider using [[oneOnOneId]] to generate one.
     */
    getOrCreateConversation(conversationId: string): published.ConversationBuilder;
    /**
     * The Inbox is the main UI component of TalkJS. It shows a user's conversation
     * history and it allows them to write messages. You typically want to call the
     * `mount` method after creating the Inbox to make it visible on your app.
     *
     * Call `createInbox` on the messaging page of your app.
     *
     * @param options Optional. Use these to finetune the behavior of the Inbox.
     */
    createInbox(options?: InboxOptions): ui.Inbox;
    /**
     * The Chatbox is a slimmer version of the Inbox. It shows a single conversation,
     * without a means to switch between conversations. You typically want to call the
     * `mount` method after creating the Chabox to make it visible on your app.
     *
     * Call `createChatbox` on any page you want to show a chatbox of a single conversation.
     *
     * @param options Optional. Use these to finetune the behavior of the Chatbox.
     */
    createChatbox(selectedConversation: published.Conversation | published.ConversationBuilder, options?: ChatboxOptions): ui.Chatbox;
    /**
     * The Popup is a beautiful, well positioned box containing a conversation. It shows a single conversation,
     * without a means to switch between conversations. In order to have a popup on each site you need to call
     * `createPopup` on any page you want to show a popup with the conversation.
     */
    createPopup(conversation: published.Conversation | published.ConversationBuilder, options?: PopupOptions): ui.Popup;
    /**
     */
    syncThemeForLocalDev(path: string): void;
    /**
     * Sets desktop notification on or off. Has the same effect as toggling the
     * "Desktop notification" toggle in the TalkJS Inbox UI. Use this function to replicate that
     * toggle elsewhere in your UI if you're using TalkJS in a mode that doesn't show this toggle.
     *
     * @returns void
     */
    setDesktopNotificationEnabled(isEnabled: boolean): void;
    private _cleanUIBoxs;
    /**
     * Registers mobile device, one user can be connected to one mobile device.
     */
    registerDevice({ platform, pushRegistrationId }: {
        platform: "ios" | "android";
        pushRegistrationId: string;
    }): Promise<void>;
    /**
     */
    unregisterDevice(): Promise<void>;
    private _selectConversationInActiveInbox;
    /**
     * A "message" event is fired every time a message is sent or received by the
     * current user (even if no TalkJS UI is visible). Your `handler` function is passed
     * a [[Message]] object with some information about each message and its conversation.
     *
     * For an example, see https://gist.github.com/eteeselink/607e585eb40be76f2ed150d4090e5261
     */
    on(eventType: "message", handler: (message: published.Message) => void): void;
    /**
     * Call this with the same `eventType` and `handler` to stop receiving events.
     */
    off(eventType: "message", handler: (message: published.Message) => void): void;
}
/**
 * A helper method to predictably compute a Conversation ID based on participants' ids in the given conversation.
 * Use this method if you want to simply create a conversation between two users,
 * not related to a particular product, order or transaction.
 *
 * The order of the parameters does not matter.
 * For example, `Talk.oneOnOneId("a", "b")` yields the same result as `Talk.oneOnOneId("b", "a")`.
 *
 * This method takes the following steps:
 * 1. Take two ids of users and put them in an array
 * 2. Sort them lexicographically
 * 3. JSON encode them
 * 4. hash the result using SHA1, return the first 20 characters
 *
 * In pseudocode, this is what this function does:
 *
 *     var sorted = [me.id, other.id].sort()
 *     var encoded = JSON.encode(sorted)
 *     var hash = sha1(encoded)
 *     return truncate(hash, 20)
 *
 * For a PHP implementation, see https://gist.github.com/eteeselink/4dc3ad32cc478986ff2b5b6361a1825f.
 * [Get in touch](https://talkjs.com/?chat) if you need our help implementing this in your backend language.
 */
export declare function oneOnOneId(me: User | string, other: User | string): string;
