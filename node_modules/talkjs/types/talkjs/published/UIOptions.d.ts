import { Conversation, ConversationBuilder } from "./Domain";
export interface FullStoryOptions {
    host?: string;
    org: string;
}
export interface ThirdPartyOptions {
    fullstory?: FullStoryOptions;
}
export interface ChatboxOptions {
    /**
     * Optional. Controls the text direction (for supporting right-to-left languages such as Arabic and Hebrew). TalkJS tries
     * to determine the appropriate text direction from the parent page, but if that does not work or you want to
     * explicitly control it, you can override it here.
     */
    dir?: "rtl" | "ltr";
    /**
     * Optional. Sets the message input box to the given text.
     * You can use this to suggest a certain initial message to be sent. The user can still edit it before hitting "send".
     */
    messageSuggestion?: string;
    /**
     * Optional, defaults to true. Set to false to make TalkJS display the
     * chat without its header (the upper bar that shows names and the user's photo).
     */
    showChatHeader?: boolean;
    /**
     * Controls what text appears in the chat title, in the header above the messages.
     * Defaults to `"participants"`.
     *
     * (also see [[ChatboxOptions.chatSubtitleMode]] and [[InboxOptions.feedConversationTitleMode]])
     */
    chatTitleMode?: "subject" | "participants";
    /**
     * Controls what text appears in the chat subtitle, right below the chat title.
     * No subtitle is displayed when the conversation has no subject set or when set to `null`.
     * Defaults to `"subject"`.
     *
     * (also see [[ChatboxOptions.chatTitleMode]] and [[InboxOptions.feedConversationTitleMode]])
     */
    chatSubtitleMode?: "subject" | "participants" | null;
    /**
     * TalkJS leverages `iframe`s behind the scenes and therefore not all services that you use in your app will work out of the box.
     * This option adds support for a number of services to help you use them. Let us know if you're missing any.
     */
    thirdparties?: ThirdPartyOptions;
}
export interface PopupOptions extends ChatboxOptions {
    /**
     * Optional, defaults to `true`. If enabled, the Popup will reopen every time
     * the user navigates to another page. This way, a conversation can continue
     * while the user browses around. Set to `false` to disable this behavior.
     */
    keepOpen?: boolean;
    /**
     * Optional, defaults to `"close-only"`. Specifies whether to show a round
     * launcher and/or close button beneath the popup in the right bottom corner
     * of the page.
     *
     * * `"close-only"`: show a close button beneath the popup, but don't show a launch button
     * * `"always"`: show a launch button when the popup is closed, show a close button when it is visible
     * * `"never"`: never show a launcher
     *
     * Note: if you choose `"never"` you may want to override the positioning of the popup as well.
     * Just tune the `__talkjs_popup` class in your CSS.
     *
     * Ignored on mobile, where the popup fills the entire screen so the value is effectively `"never"`.
     *
     */
    launcher?: "close-only" | "always" | "never";
    /**
     * Optional. Whether to show a little "x" in the popup header to close the popup.
     * "auto", which is the default value means `true` on mobile and to `false` on desktop.
     */
    showCloseInHeader?: boolean | "auto";
}
export interface InboxOptions extends ChatboxOptions {
    /**
     * Optional. either a `Conversation` object (as returned from
     * `getOrCreateConversation`) or the `id` field of a conversation. If given,
     * makes the inbox start up with that conversation selected.
     */
    selected?: Conversation | ConversationBuilder | string | null;
    /**
     * Optional, defaults to true. Set to false to make TalkJS display the
     * chat feed without its header. On desktop, this header contains the
     * toggle to enable desktop notifications, so you may want to implement
     * that toggle yourself using [[Session.setDesktopNotificationEnabled]].
     */
    showFeedHeader?: boolean;
    /**
     * Controls how a chat is displayed in the feed of chats.
     *
     * Note: when set to `"subject"` but a conversation has no subject set, then
     * TalkJS falls back to `"participants"`.
     *
     * When not set, defaults to `"auto"`, which means that in group conversations
     * that have a subject set, the subject is displayed and otherwise the participants.
     *
     * (also see [[ChatboxOptions.chatSubtitleMode]] and [[ChatboxOptions.chatTitleMode]])
     */
    feedConversationTitleMode?: "participants" | "subject" | "auto";
    /**
     * Controls whether the user navigating between conversation should count
     * as steps in the browser history. Defaults to true, which means that if the user
     * clicks the browser's back button, they go back to the previous conversation
     * (if any).
     */
    useBrowserHistory?: boolean;
    /**
     * Used to control which conversations are shown in the conversation feed, depending on access
     * level, custom conversation attributes or message read status.
     *
     * See [[ConversationFilter]] for all available options.
     *
     * You can also modify the filter on the fly using [[Inbox.setFeedFilter]].
     *
     * @published
     */
    feedFilter?: ConversationFilter;
}
export interface HtmlPanelOptions {
    /**
     * Required. URL you want to load inside the HTML panel.
     * Url can be absolute ("https://www.mycompany.com/register-form.html") or relative ("register-form.html").
     * We recommend using same origin pages to have better control of the page.
     * Learn more about HTML Panels and same origin pages [here](https://talkjs.com/docs/Customizations/HTML_Panels.html).
     */
    url: string;
    /**
     * Optional, defaults to 300 (px).
     */
    height?: number;
    /**
     * Optional, defaults to true. Set false if you don't want the HTML panel to be shown after
     * `createHtmlPanel` is called. You can change the visibility of the HTML panels by
     * calling `.hide()` or `.show()` on the `HtmlPanel` instance returned by `createHtmlPanel`'s promise.
     */
    show?: boolean;
    /**
     * Either a `Conversation` object
     * (as returned from `getOrCreateConversation`) or the `id` field of
     * a conversation (which you may have stored in your database).
     * If given the HTML panel called will only show up for that conversation.
     */
    conversation?: Conversation | ConversationBuilder | string;
}
export interface HtmlPanelOptionsSet {
    global?: HtmlPanelOptions;
    perConv: {
        [conversationId: string]: HtmlPanelOptions;
    };
}
export declare type ConversationAccessLevel = "ReadWrite" | "Read" | "None";
export declare type FieldPredicate<T> = ["==" | "!=", T] | ["oneOf" | "!oneOf", T[]];
export declare type CustomFieldPredicate = FieldPredicate<string> | "exists" | "!exists";
/**
 * Allows you to filter conversations down to a specific subset.
 *
 * Use with [[Inbox.setFeedFilter]] or pass [[InboxOptions.feedFilter]] to [[Session.createInbox]].
 */
export interface ConversationFilter {
    /**
     * Only select conversations that the current user as specific access to.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * * `"=="`
     * * `"!="`
     * * `"oneOf"`
     * * `"!oneOf"`.
     *
     * The operand must be either a string (one of `"ReadWrite"`, `"Read"` or `"None"`) or an array of strings (for the `oneOf` operators).
     *
     * Example:
     * ```js
     * // to remove conversations that the user has no access to anymore, do:
     * { access: ["!=", "None"] }
     * ```
     */
    access?: FieldPredicate<ConversationAccessLevel>;
    /**
     * Only select conversations that have particular custom fields set to particular values.
     *
     * Every key must correspond to a key in the custom conversation data that you set (by passing
     * `custom` to [[ConversationBuilder.setAttributes]]). It is not necessary for all
     * conversations to have these keys.
     *
     * Each value must be one of the following:
     * *   A string, equal to `"exists"` or `"!exists"`
     * *   A 2-element array of `[operator, operand]` structure.  The operand must be either a
     *     string or an array of strings (for the `oneOf` operators). Valid operators are:
     *     *   `"=="`
     *     *   `"!="`
     *     *   `"oneOf"`
     *     *   `"!oneOf"`.
     *
     * Examples, assuming you have set a `category` custom field on your conversations:
     *
     * ```js
     * // only show conversations that have no category set:
     * { custom: { category: "!exists" } }
     *
     * // only show conversations of category "shoes"
     * { custom: { category: ["==", "shoes"] } }
     *
     * // only show conversations either category "shoes" or "sandals"
     * { custom: { category: ["oneOf", ["shoes", "sandals"] ] } }
     *
     * // only show conversations about shoes that are marked visible.
     * // this assumes you also have a custom field called `visibility`
     * { custom: { category: ["==", "shoes"], visibility: ["==", "visible" ] } }
     * ```
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
    /**
     * Set this field to only select conversations that have, or don't have any, unread messages.
     */
    hasUnreadMessages?: boolean;
}
